## 아이템 26. 로 타입은 사용하지 말라


```java
private final Collection stamps = ...;
```
Collection을 로 타입으로 선언했을 시 의도하지 않은 인스턴스 타입을 넣어도 오류가 나지 않는다. 


```java
private final Collection<Stamp> stamps = ...;
```
Collection을 매개변수화 타입으로 선언하면 컴파일러가 Collection에 어떤 인스턴스를 넣어야 하는지
인지할 수 있고, 정상적인 컴파일 또한 보장된다. 

그러면 제네릭의 장점인 `안정성과 표현력`이 사라진 로 타입이 애초에 왜 존재할까?   

자바5에서 등장한 제네릭과 기존 코드 간의 **호환성** 때문이다. 

로 타입을 지원하여 기존 코드는 로 타입으로 인식하고, 제네릭은 소거 방식(컴파일 시 제네릭 타입은 
모두 매개변수 타입으로 전환된다.)으로 동작하게 한다. 

### 로타입을 통해 느끼는 제네릭의 장점 - 안정성   

`List<Object>`에서 매개변수 타입이 Object면, Object가 어차피 최상위 객체이니까 임의 객체를 허용한다는 관점에서
로 타입인 `List`와 별다를거 없지 않을까???   

그렇지 않다. List에는 String값을 넘길 수 있지만, List<Object>에는 String 값을 넘길  수 없다. 
> (아이템 28) 제네릭은 불공변이다. 즉, 서로 다른 타입 Type1, Type2가 있을 때, `List<Type1>`은
> `List<Type2>`의 하위 타입도 아니고 상위타입도 아니다. 

그래서 `List<Object> list = new ArrayList<String>();` 은 Object와 String이 호환되지 않기 때문에
컴파일 할 수가 없다. 

따라서 로 타입은 타입 안전성이 떨어진다. 






원소의 타입을 모른다면 로 타입 대신 비한정적 와일드카드 타입을 대신 사용하는 것이 좋다.   
제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 `<?>`를 사용하자.

